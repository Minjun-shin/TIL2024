# 01.22.

## 데이터 구조 1

- 여러 데이터를 효과적으로 활용하고 관리하기 위한 구조
- = 자료 구조
- 활용 - **메서드 호출**

### 메서드

- 객체(class)에 속한 함수
- 호출 방법 - `데이터_타입_객체.메서드()`
- ex) `list.append(parameter)`, `str.upper()`

### 시퀀스 데이터 구조

- 조회, 탐색 및 검증

| method | 설명 |
| --- | --- |
| s.find(x) | x의 첫번째 위치 반환, 없으면 -1 반환 |
| s.index(x) | x의 첫번째 위치 반환, 없으면 에러 발생 |
| s.isalpha() | 알파벳 문자 여부 (유니 코드상 → 한국어 포함) |
| s.isupper() | 대문자 여부 |
| s.islower() | 소문자 여부 |
- 조작 메서드 (변경 불가능한 데이터 구조 → 새 문자열 반환)

| method | 설명 |
| --- | --- |
| s.replace(old, new[, count]) | 바꿀 대상 글자를 새로운 글자로 바꿔서 반환 |
| s.strip([char]) | 문자열의 시작과 끝에 있는 공백이나 특정 문자 제거 |
| s.split(sep=None, maxsplit=-1) | 지정한 문자를 구분자로 문자열을 분리하여 문자열의 리스트로 반환 |
| ‘separator’.join(iterable) | iterable 요소들을 원래의 문자열을 구분자로 이용하여 하나의 문자열로 연결 |
| s.capitalize() | 가장 첫번째 글자를 대문자로 나머지는 소문자로 변경 |
| s.title() | 띄어쓰기를 기준으로 각 단어의 첫 글자를 대문자로 나머지는 소문자로 변경 |
| s.upper() | 대문자로 변경 |
| s.lower() | 소문자로 변경 |
| s.swapcase() | 대문자 ↔ 소문자 |
- `[, count]`, `[char]`는 optional을 표현하는 표기법 - 언어 무관
    - 배커스-나우르 표기법
    - python - EBNF

### 리스트 - (가변 → 메서드 자체 반환값 = None)

- 추가 및 삭제 메서드

| method | 설명 |
| --- | --- |
| L.append(x) | 리스트의 마지막에 요소 추가 |
| L.extend(m) | iterable m의 모든 요소들을 리스트 끝에 추가 |
| L.insert(i, x) | 인덱스 i 에 항목 추가 |
| L.remove(x) | 리스트 가장 왼쪽에 위치하는 x 제거, 없으면 ValueError 발생 |
| L.pop() | 리스트 가장 오른쪽의 항목을 반환하며 제거 - 반환값 있음 |
| L.pop(i) | 인덱스 i의 항목을 반환하며 제거 - 반환값 있음 |
| L.clear() | 리스트 모든 항목 제거 |
- 탐색 및 정렬 메서드

| method | 설명 |
| --- | --- |
| L.index(x, start, end) | 리스트에 있는 항목 중 가장 왼쪽에 있는 x의 인덱스 반환 |
| L.reverse() | 리스트의 순서를 역순으로 정렬 |
| L.sort() | 리스트의 순서를 오름차순으로 정렬 |
| L.count(x) | 리스트 속 항목 x의 개수 반환 |

## 복사

변경 가능한 데이터 타입과 변경 불가능한 데이터 타입에 따라 결과가 다름

### 변경 가능한 데이터 타입

```python
a = [1, 2, 3, 4]
b = a
b[0] = 100

print(a) # [100, 2, 3, 4]
print(b) # [100, 2, 3, 4]
```

### 변경 불가능한 데이터 타입

```python
a = 20
b = a
b = 10

print(a) # 20
print(b) # 10
```

- 할당 연산자를 통한 리스트 복사는 객체 참조를 복사 → 객체 자체가 바뀌면 이를 참조하는 모든 리스트도 변화
- 얕은 복사
    - 슬라이싱을 통해 생성된 객체는 독립적으로 존재
    
    ```python
    a = [1, 2, 3]
    b = a[:]
    b[0] = 100
    
    print(a) # [1, 2, 3]
    print(b) # [100, 2, 3]
    ```
    
    - 한계 - 변경 가능한 객체 속 변경 가능한 객체는 여전히 독립적이지 않음
    
    ```python
    a = [1, 2, [1, 2]]
    b = a[:]
    b[-1][0] = 100
    
    print(a) # [1, 2, [100, 2]]
    print(b) # [1, 2, [100, 2]]
    ```
    
- 깊은 복사
    
    ```python
    import copy
    
    a = [1, 2, [1, 2]]
    b = copy.deepcopy(a)
    b[-1][0] = 100
    
    print(a) # [1, 2, [1, 2]]
    print(b) # [1, 2, [100, 2]]
    ```
    

isdecimal() ⊆ isdigit() ⊆ isnumeric()